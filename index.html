<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sunflower Land Price Dashboard</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f8f9fa;
            padding: 20px;
        }
        .card {
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }
        .card-header {
            background-color: #4a6741;
            color: white;
            border-radius: 10px 10px 0 0 !important;
            padding: 15px 20px;
        }
        .form-select {
            border-radius: 5px;
            padding: 10px;
        }
        .btn-primary {
            background-color: #4a6741;
            border-color: #4a6741;
        }
        .btn-primary:hover {
            background-color: #3a5331;
            border-color: #3a5331;
        }
        .chart-container {
            position: relative;
            height: 400px;
            width: 100%;
        }
        .loading {
            display: none;
            text-align: center;
            padding: 20px;
        }
        .date-range {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
        }
        .sparkline-card {
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            height: 100%;
        }
        .sparkline-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.15);
        }
        .sparkline-container {
            height: 80px;
            width: 100%;
        }
        .sparkline-title {
            font-size: 0.9rem;
            font-weight: 600;
            text-align: center;
            margin-bottom: 5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .price-change {
            font-size: 0.8rem;
            font-weight: 600;
            text-align: center;
            margin-top: 5px;
        }
        .price-up {
            color: #28a745;
        }
        .price-down {
            color: #dc3545;
        }
        .price-neutral {
            color: #6c757d;
        }
        /* Estilo para as imagens nos mini gráficos */
        .item-img {
            width: 32px;
            height: 32px;
            object-fit: contain;
            margin-bottom: 5px;
        }
        /* Estilo para o select com imagens */
        select option {
            padding: 5px;
        }
        .select-with-image {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        /* Estilos para a recomendação de mercado */
        .market-recommendation {
            font-size: 0.75rem;
            font-weight: 600;
            text-align: center;
            padding: 2px 5px;
            border-radius: 3px;
            margin-top: 3px;
        }
        .p2p-better {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .ge-better {
            background-color: #cce5ff;
            color: #004085;
            border: 1px solid #b8daff;
        }
        .markets-equal {
            background-color: #ffeeba;
            color: #856404;
            border: 1px solid #ffeeba;
        }
        /* Estilo para o indicador de estrela */
        .star-indicator {
            position: absolute;
            top: 5px;
            right: 5px;
            color: gold;
            font-size: 1.2rem;
            text-shadow: 0 0 2px rgba(0,0,0,0.5);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-center my-4">Sunflower Land Price Dashboard</h1>
        
        <div class="row">
            <div class="col-md-4">
                <div class="card">
                    <div class="card-header">
                        <h5 class="mb-0">Configurações</h5>
                    </div>
                    <div class="card-body">
                        <div class="mb-3">
                            <label for="itemSelect" class="form-label">Selecione um Item:</label>
                            <select class="form-select" id="itemSelect">
                                <option value="" selected disabled>Escolha um item...</option>
                                {% for item in items %}
                                <option value="{{ item }}" data-img="/images/{{ item|lower }}.png">{{ item }}</option>
                                {% endfor %}
                            </select>
                        </div>
                        
                        <div class="mb-3">
                            <label class="form-label">Período:</label>
                            <select class="form-select" id="timeRange">
                                <option value="1">Diário</option>
                                <option value="7">Últimos 7 dias</option>
                                <option value="14">Últimos 14 dias</option>
                                <option value="30" selected>Últimos 30 dias</option>
                                <option value="60">Últimos 60 dias</option>
                                <option value="90">Últimos 90 dias</option>
                            </select>
                        </div>
                        
                        <button id="updateBtn" class="btn btn-primary w-100">Atualizar Gráfico</button>
                    </div>
                </div>
            </div>
            
            <div class="col-md-8">
                <div class="card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h5 class="mb-0">Histórico de Preços</h5>
                        <div class="form-check form-switch">
                            <input class="form-check-input" type="checkbox" id="logScaleToggle">
                            <label class="form-check-label text-white" for="logScaleToggle">Escala Logarítmica</label>
                        </div>
                    </div>
                    <div class="card-body">
                        <div id="loading" class="loading">
                            <div class="spinner-border text-primary" role="status">
                                <span class="visually-hidden">Carregando...</span>
                            </div>
                            <p class="mt-2">Carregando dados...</p>
                        </div>
                        <div id="noDataMessage" class="text-center py-5" style="display: none;">
                            <h4>Selecione um item para visualizar o histórico de preços</h4>
                        </div>
                        <div id="priceChangeInfo" class="text-center mb-2" style="display: none;">
                            <div class="d-flex justify-content-center align-items-center">
                                <img id="itemImage" class="item-img me-2" style="width: 24px; height: 24px;" alt="">
                                <span class="fw-bold">Variação no período: <span id="priceChangeValue"></span></span>
                            </div>
                        </div>
                        <div class="chart-container">
                            <canvas id="priceChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Mini gráficos (Sparklines) -->
        <div class="row mt-4" id="sparklines-container">
            <div class="col-12">
                <div class="card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h5 class="mb-0">Mini Gráficos</h5>
                        <div class="d-flex align-items-center">
                            <div class="form-check form-switch me-3">
                                <input class="form-check-input" type="checkbox" id="starFilterToggle">
                                <label class="form-check-label text-white" for="starFilterToggle">Mostrar apenas com ★</label>
                            </div>
                            <div class="btn-group" role="group" aria-label="Opções de classificação">
                                <button type="button" class="btn btn-sm btn-outline-light" id="sort-alpha-asc">A-Z</button>
                                <button type="button" class="btn btn-sm btn-outline-light" id="sort-alpha-desc">Z-A</button>
                                <button type="button" class="btn btn-sm btn-outline-light" id="sort-percent-desc">% ↓</button>
                                <button type="button" class="btn btn-sm btn-outline-light" id="sort-percent-asc">% ↑</button>
                            </div>
                        </div>
                    </div>
                    <div class="card-body">
                        <div id="sparklines-loading" class="loading">
                            <div class="spinner-border text-primary" role="status">
                                <span class="visually-hidden">Carregando...</span>
                            </div>
                            <p class="mt-2">Carregando mini gráficos...</p>
                        </div>
                        <div id="sparklines-grid" class="row g-3">
                            <!-- Mini gráficos serão inseridos aqui dinamicamente -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let priceChart = null;
        let sparklineCharts = {};
        const chartColors = {
            p2p: 'rgb(54, 162, 235)',
            discount: 'rgb(255, 159, 64)',
            ge: 'rgb(75, 192, 192)'
        };
        let allItems = [];

        // Initialize the page
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('noDataMessage').style.display = 'block';
            document.getElementById('updateBtn').addEventListener('click', updateChart);
            document.getElementById('logScaleToggle').addEventListener('change', updateChartScale);
            
            // Adicionar imagens ao combobox
            const itemSelect = document.getElementById('itemSelect');
            for (let i = 0; i < itemSelect.options.length; i++) {
                const option = itemSelect.options[i];
                if (option.dataset.img) {
                    const imgPath = option.dataset.img;
                    const img = new Image();
                    img.src = imgPath;
                    img.onload = function() {
                        option.innerHTML = `<img src="${imgPath}" class="item-img" style="width: 20px; height: 20px; margin-right: 8px;">${option.text}`;
                    };
                    img.onerror = function() {
                        // Try WebP format if PNG fails
                        const webpImgPath = imgPath.replace('.png', '.webp');
                        const webpImg = new Image();
                        webpImg.src = webpImgPath;
                        webpImg.onload = function() {
                            option.innerHTML = `<img src="${webpImgPath}" class="item-img" style="width: 20px; height: 20px; margin-right: 8px;">${option.text}`;
                        };
                    };
                }
            }
            
            // Carregar todos os itens disponíveis
            fetch('https://api-flask-y3l3.onrender.com/api/items')
                .then(response => response.json())
                .then(items => {
                    allItems = items;
                    
                    // Preencher o combobox com os itens e suas imagens
                    const itemSelect = document.getElementById('itemSelect');
                    // Limpar opções existentes, mantendo apenas a primeira
                    while (itemSelect.options.length > 1) {
                        itemSelect.remove(1);
                    }
                    
                    items.forEach(item => {
                        const option = document.createElement('option');
                        option.value = item;
                        
                        // Criar um elemento temporário para formatar a opção com imagem
                        const tempDiv = document.createElement('div');
                        tempDiv.style.display = 'flex';
                        tempDiv.style.alignItems = 'center';
                        
                        const imgPath = `/images/${item.toLowerCase()}.png`;
                        
                        // Verificar se a imagem existe (primeiro PNG, depois WebP)
                        const img = new Image();
                        img.src = imgPath;
                        img.onload = function() {
                            // Se a imagem PNG existir, adicionar ao texto da opção
                            option.innerHTML = `<div style="display: flex; align-items: center;">
                                <img src="${imgPath}" style="width: 20px; height: 20px; margin-right: 8px;">
                                <span>${item}</span>
                            </div>`;
                        };
                        img.onerror = function() {
                            // Se a imagem PNG não existir, tentar WebP
                            const webpImgPath = `/images/${item.toLowerCase()}.webp`;
                            const webpImg = new Image();
                            webpImg.src = webpImgPath;
                            webpImg.onload = function() {
                                // Se a imagem WebP existir, adicionar ao texto da opção
                                option.innerHTML = `<div style="display: flex; align-items: center;">
                                    <img src="${webpImgPath}" style="width: 20px; height: 20px; margin-right: 8px;">
                                    <span>${item}</span>
                                </div>`;
                            };
                            webpImg.onerror = function() {
                                // Se nenhuma imagem existir, mostrar apenas o texto
                                option.textContent = item;
                            };
                        };
                        
                        itemSelect.appendChild(option);
                    });
                    
                    loadSparklines();
                })
                .catch(error => {
                    console.error('Erro ao carregar itens:', error);
                });
        });
        
        // Carregar mini gráficos para todos os itens, um por vez
        function loadSparklines() {
            document.getElementById('sparklines-loading').style.display = 'block';
            document.getElementById('sparklines-grid').innerHTML = '';
            
            // Usar todos os itens disponíveis
            const itemsToShow = allItems;
            
            // Criar um grid de mini gráficos
            itemsToShow.forEach(item => {
                createSparklineCard(item);
            });
            
            // Contador para acompanhar o progresso
            let loadedCount = 0;
            const totalItems = itemsToShow.length;
            
            // Elemento para mostrar o progresso
            const loadingElement = document.getElementById('sparklines-loading');
            loadingElement.innerHTML = `
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Carregando...</span>
                </div>
                <p class="mt-2">Carregando mini gráficos... (0/${totalItems})</p>
            `;
            
            // Função para carregar um item por vez
            function loadNextItem(index) {
                if (index >= itemsToShow.length) {
                    // Todos os itens foram carregados
                    document.getElementById('sparklines-loading').style.display = 'none';
                    return;
                }
                
                const item = itemsToShow[index];
                
                // Atualizar mensagem de carregamento
                loadingElement.innerHTML = `
                    <div class="spinner-border text-primary" role="status">
                        <span class="visually-hidden">Carregando...</span>
                    </div>
                    <p class="mt-2">Carregando mini gráficos... (${index+1}/${totalItems})</p>
                    <p class="small text-muted">Carregando: ${item}</p>
                `;
                
                // Buscar dados para o item atual
                fetch(`https://api-flask-y3l3.onrender.com/api/price_history?item=${encodeURIComponent(item)}&days=1`)
                    .then(response => response.json())
                    .then(data => {
                        if (data.length > 0) {
                            renderSparkline(item, data);
                        }
                        
                        // Incrementar contador
                        loadedCount++;
                        
                        // Carregar próximo item após um pequeno delay
                        setTimeout(() => loadNextItem(index + 1), 100);
                    })
                    .catch(error => {
                        console.error(`Erro ao carregar mini gráfico para ${item}:`, error);
                        // Continuar para o próximo item mesmo em caso de erro
                        setTimeout(() => loadNextItem(index + 1), 100);
                    });
            }
            
            // Iniciar o carregamento sequencial
            loadNextItem(0);
        }
        
        // Criar card para o mini gráfico
        function createSparklineCard(item) {
            const col = document.createElement('div');
            col.className = 'col-md-3 col-sm-6';
            
            const card = document.createElement('div');
            card.className = 'card sparkline-card';
            card.id = `sparkline-card-${item.replace(/\s+/g, '-').toLowerCase()}`;
            card.dataset.item = item;
            card.addEventListener('click', function() {
                document.getElementById('itemSelect').value = item;
                updateChart();
            });
            
            const cardBody = document.createElement('div');
            cardBody.className = 'card-body p-2';
            
            // Adicionar imagem do item
            const imgContainer = document.createElement('div');
            imgContainer.className = 'd-flex justify-content-center mb-2';
            
            // Criar apenas uma imagem por container
            const img = document.createElement('img');
            img.src = `/images/${item.toLowerCase()}.png`;
            img.alt = item;
            img.style.width = '32px';
            img.style.height = '32px';
            img.onerror = function() {
                // Try WebP format if PNG fails
                this.src = `/images/${item.toLowerCase()}.webp`;
                this.onerror = function() {
                    this.style.display = 'none';
                };
            };
            
            // Garantir que o container esteja vazio antes de adicionar a imagem
            imgContainer.innerHTML = '';
            imgContainer.appendChild(img);
            
            const title = document.createElement('div');
            title.className = 'sparkline-title';
            title.textContent = item;
            
            const sparklineContainer = document.createElement('div');
            sparklineContainer.className = 'sparkline-container';
            
            const canvas = document.createElement('canvas');
            canvas.id = `sparkline-${item.replace(/\s+/g, '-').toLowerCase()}`;
            
            // Adicionar elemento para mostrar a variação de preço em 24h
            const priceChange = document.createElement('div');
            priceChange.className = 'price-change';
            priceChange.id = `price-change-${item.replace(/\s+/g, '-').toLowerCase()}`;
            priceChange.textContent = 'Carregando...';
            
            // Adicionar elemento para a recomendação de mercado
            const marketRecommendation = document.createElement('div');
            marketRecommendation.className = 'market-recommendation';
            marketRecommendation.id = `market-recommendation-${item.replace(/\s+/g, '-').toLowerCase()}`;
            marketRecommendation.textContent = 'Comparando...';
            
            sparklineContainer.appendChild(canvas);
            cardBody.appendChild(imgContainer);
            cardBody.appendChild(title);
            cardBody.appendChild(sparklineContainer);
            cardBody.appendChild(priceChange);
            cardBody.appendChild(marketRecommendation);
            card.appendChild(cardBody);
            col.appendChild(card);
            
            document.getElementById('sparklines-grid').appendChild(col);
        }
        
        // Renderizar mini gráfico
        function renderSparkline(item, data) {
            const canvasId = `sparkline-${item.replace(/\s+/g, '-').toLowerCase()}`;
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            
            const timestamps = data.map(item => item.timestamp);
            const p2pPrices = data.map(item => item.p2p_price);
            const gePrices = data.map(item => item.ge_price);
            
            // Calcular a variação de preço em 24 horas
            let priceChangeText = 'Sem dados';
            let priceChangeClass = 'price-neutral';
            
            if (p2pPrices.length >= 2) {
                const firstPrice = p2pPrices[0];
                const lastPrice = p2pPrices[p2pPrices.length - 1];
                const priceDiff = lastPrice - firstPrice;
                const percentChange = (priceDiff / firstPrice) * 100;
                
                // Formatar a variação de preço
                const sign = percentChange > 0 ? '+' : '';
                priceChangeText = `${sign}${percentChange.toFixed(2)}%`;
                
                // Definir a classe CSS com base na direção da variação
                if (percentChange > 0) {
                    priceChangeClass = 'price-up';
                } else if (percentChange < 0) {
                    priceChangeClass = 'price-down';
                } else {
                    priceChangeClass = 'price-neutral';
                }
            }
            
            // Atualizar o elemento de variação de preço
            const priceChangeElement = document.getElementById(`price-change-${item.replace(/\s+/g, '-').toLowerCase()}`);
            if (priceChangeElement) {
                priceChangeElement.textContent = priceChangeText;
                priceChangeElement.className = `price-change ${priceChangeClass}`;
            }
            
            // Adicionar comparação entre P2P (com taxa de 10%) e GE
            // Criar ou atualizar o elemento de recomendação
            let marketRecommendation = document.getElementById(`market-recommendation-${item.replace(/\s+/g, '-').toLowerCase()}`);
            
            if (!marketRecommendation) {
                marketRecommendation = document.createElement('div');
                marketRecommendation.id = `market-recommendation-${item.replace(/\s+/g, '-').toLowerCase()}`;
                marketRecommendation.className = 'market-recommendation mt-1';
                priceChangeElement.parentNode.insertBefore(marketRecommendation, priceChangeElement.nextSibling);
            }
            
            if (p2pPrices.length > 0 && gePrices && gePrices.length > 0 && gePrices[gePrices.length - 1] !== null) {
                const lastP2PPrice = p2pPrices[p2pPrices.length - 1];
                const lastGEPrice = gePrices[gePrices.length - 1];
                
                // Calcular preço efetivo do P2P após taxa de 10%
                const effectiveP2PPrice = lastP2PPrice * 0.9; // 10% de taxa
                
                // Determinar qual mercado é mais lucrativo
                if (effectiveP2PPrice > lastGEPrice) {
                    marketRecommendation.textContent = 'Melhor: P2P';
                    marketRecommendation.className = 'market-recommendation mt-1 p2p-better';
                } else if (lastGEPrice > effectiveP2PPrice) {
                    marketRecommendation.textContent = 'Melhor: GE';
                    marketRecommendation.className = 'market-recommendation mt-1 ge-better';
                } else {
                    marketRecommendation.textContent = 'P2P = GE';
                    marketRecommendation.className = 'market-recommendation mt-1 markets-equal';
                }
                
                // Adicionar estrela se o preço do GE for maior que o P2P
                if (lastGEPrice > lastP2PPrice) {
                    // Verificar se já existe uma estrela
                    const cardElement = document.getElementById(`sparkline-card-${item.replace(/\s+/g, '-').toLowerCase()}`);
                    if (cardElement && !cardElement.querySelector('.star-indicator')) {
                        const starIndicator = document.createElement('div');
                        starIndicator.className = 'star-indicator';
                        starIndicator.innerHTML = '★';
                        cardElement.style.position = 'relative';
                        cardElement.appendChild(starIndicator);
                    }
                }
            } else {
                marketRecommendation.textContent = 'Melhor: P2P';
                marketRecommendation.className = 'market-recommendation mt-1 p2p-better';
            }
            
            // Destruir gráfico existente se houver
            if (sparklineCharts[item]) {
                sparklineCharts[item].destroy();
            }
            
            // Criar novo mini gráfico
            const ctx = canvas.getContext('2d');
            sparklineCharts[item] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: timestamps,
                    datasets: [{
                        label: 'Preço',
                        data: p2pPrices,
                        borderColor: chartColors.p2p,
                        backgroundColor: 'rgba(54, 162, 235, 0.1)',
                        borderWidth: 1.5,
                        pointRadius: 0,
                        pointHoverRadius: 3,
                        fill: true,
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    return `Preço: ${context.parsed.y.toFixed(4)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: { display: false },
                        y: { display: false }
                    },
                    interaction: {
                        mode: 'nearest',
                        axis: 'x',
                        intersect: false
                    }
                }
            });
        }

        // Update chart scale (linear/logarithmic)
        function updateChartScale() {
            if (!priceChart) return;
            
            const isLogarithmic = document.getElementById('logScaleToggle').checked;
            priceChart.options.scales.y.type = isLogarithmic ? 'logarithmic' : 'linear';
            priceChart.update();
        }

        // Fetch data and update chart
        function updateChart() {
            const itemSelect = document.getElementById('itemSelect');
            const timeRange = document.getElementById('timeRange');
            
            if (!itemSelect.value) {
                alert('Por favor, selecione um item');
                return;
            }
            
            const item = itemSelect.value;
            const days = timeRange.value;
            
            // Show loading indicator
            document.getElementById('loading').style.display = 'block';
            document.getElementById('noDataMessage').style.display = 'none';
            
            // Se o período for diário (1 dia), recarregar os mini gráficos
            if (days === '1') {
                loadSparklines();
            }
            
            // Fetch price history data
            fetch(`https://api-flask-y3l3.onrender.com/api/price_history?item=${encodeURIComponent(item)}&days=${days}`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Erro ao buscar dados');
                    }
                    return response.json();
                })
                .then(data => {
                    renderChart(data, item);
                })
                .catch(error => {
                    console.error('Error:', error);
                    alert('Erro ao buscar dados: ' + error.message);
                })
                .finally(() => {
                    document.getElementById('loading').style.display = 'none';
                });
        }

        // Render the chart with the fetched data
        function renderChart(data, itemName) {
            if (data.length === 0) {
                document.getElementById('noDataMessage').style.display = 'block';
                document.getElementById('noDataMessage').innerHTML = '<h4>Nenhum dado disponível para este item</h4>';
                return;
            }
            
            // Prepare data for Chart.js
            const timestamps = data.map(item => item.timestamp);
            const p2pPrices = data.map(item => item.p2p_price);
            const discountPrices = data.map(item => item.p2p_discount);
            const gePrices = data.map(item => item.ge_price);
            
            // Calcular a variação de preço entre o primeiro e o último registro
            let priceChangeText = '';
            let priceChangeClass = '';
            
            if (p2pPrices.length >= 2) {
                const firstPrice = p2pPrices[0];
                const lastPrice = p2pPrices[p2pPrices.length - 1];
                const priceDiff = lastPrice - firstPrice;
                const percentChange = (priceDiff / firstPrice) * 100;
                
                // Formatar a variação de preço
                const sign = percentChange > 0 ? '+' : '';
                priceChangeText = `${sign}${percentChange.toFixed(2)}%`;
                
                // Definir a classe CSS com base na direção da variação
                if (percentChange > 0) {
                    priceChangeClass = 'text-success';
                } else if (percentChange < 0) {
                    priceChangeClass = 'text-danger';
                } else {
                    priceChangeClass = 'text-muted';
                }
                
                // Exibir a informação de variação de preço no elemento dedicado
                const priceChangeInfo = document.getElementById('priceChangeInfo');
                const priceChangeValue = document.getElementById('priceChangeValue');
                const itemImage = document.getElementById('itemImage');
                
                if (priceChangeInfo && priceChangeValue) {
                    // Definir a imagem do item (tentar PNG primeiro, depois WebP)
                    if (itemImage) {
                        const imgPath = `/images/${itemName.toLowerCase()}.png`;
                        itemImage.src = imgPath;
                        itemImage.alt = itemName;
                        itemImage.onerror = function() {
                            // Try WebP format if PNG fails
                            this.src = `/images/${itemName.toLowerCase()}.webp`;
                            this.onerror = function() {
                                this.style.display = 'none';
                            };
                        };
                    }
                    
                    priceChangeInfo.style.display = 'block';
                    priceChangeValue.textContent = priceChangeText;
                    priceChangeValue.className = priceChangeClass;
                }
            } else {
                // Esconder o elemento de variação se não houver dados suficientes
                const priceChangeInfo = document.getElementById('priceChangeInfo');
                if (priceChangeInfo) {
                    priceChangeInfo.style.display = 'none';
                }
            }
            
            const isLogarithmic = document.getElementById('logScaleToggle').checked;
            
            // Destroy existing chart if it exists
            if (priceChart) {
                priceChart.destroy();
            }
            
            // Criar título para o gráfico
            let titleText = `Histórico de Preços: ${itemName} ${priceChangeText ? '(' + priceChangeText + ')' : ''}`;
            
            // Create new chart
            const ctx = document.getElementById('priceChart').getContext('2d');
            priceChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: timestamps,
                    datasets: [
                        {
                            label: 'P2P Price',
                            data: p2pPrices,
                            borderColor: chartColors.p2p,
                            backgroundColor: 'rgba(54, 162, 235, 0.1)',
                            borderWidth: 2,
                            pointRadius: 1,
                            pointHoverRadius: 5,
                            fill: false,
                            tension: 0.1
                        },
                        {
                            label: 'P2P Price -10%',
                            data: data.map(item => item.p2p_discount),
                            borderColor: 'rgb(255, 159, 64)',
                            backgroundColor: 'rgba(255, 159, 64, 0.1)',
                            borderWidth: 2,
                            pointRadius: 1,
                            pointHoverRadius: 5,
                            fill: false,
                            tension: 0.1,
                            borderDash: [5, 5]
                        },
                        {
                            label: 'Game Exchange',
                            data: gePrices,
                            borderColor: chartColors.ge,
                            backgroundColor: 'rgba(75, 192, 192, 0.1)',
                            borderWidth: 2,
                            pointRadius: 1,
                            pointHoverRadius: 5,
                            fill: false,
                            tension: 0.1
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: titleText,
                            font: {
                                size: 16
                            },
                            color: priceChangeClass || undefined
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += context.parsed.y.toFixed(4);
                                    }
                                    return label;
                                }
                            }
                        },
                        legend: {
                            position: 'top',
                        }
                    },
                    scales: {
                        x: {
                            display: true,
                            title: {
                                display: true,
                                text: 'Data/Hora'
                            }
                        },
                        y: {
                            display: true,
                            type: isLogarithmic ? 'logarithmic' : 'linear',
                            title: {
                                display: true,
                                text: 'Preço'
                            }
                        }
                    }
                }
            });
            
            // Removida a adição de imagem ao título do gráfico para evitar duplicação
            // A imagem já é exibida ao lado do texto 'Variação no período'
        }
        
        // Função para classificar os cartões de mini gráficos
        function sortSparklineCards(sortBy, order) {
            const container = document.getElementById('sparklines-grid');
            const cards = Array.from(container.querySelectorAll('.col-md-3'));
            
            cards.sort((a, b) => {
                const cardA = a.querySelector('.sparkline-card');
                const cardB = b.querySelector('.sparkline-card');
                
                if (sortBy === 'alpha') {
                    // Ordenação alfabética pelo nome do item
                    const itemA = cardA.dataset.item.toLowerCase();
                    const itemB = cardB.dataset.item.toLowerCase();
                    
                    return order === 'asc' ? 
                        itemA.localeCompare(itemB) : 
                        itemB.localeCompare(itemA);
                } else if (sortBy === 'percent') {
                    // Ordenação por percentual de variação
                    const percentA = parsePercentageValue(a.querySelector('.price-change').textContent);
                    const percentB = parsePercentageValue(b.querySelector('.price-change').textContent);
                    
                    // Se não houver dados válidos, colocar no final
                    if (isNaN(percentA)) return 1;
                    if (isNaN(percentB)) return -1;
                    if (isNaN(percentA) && isNaN(percentB)) return 0;
                    
                    return order === 'asc' ? percentA - percentB : percentB - percentA;
                }
                
                return 0;
            });
            
            // Limpar o container e adicionar os cartões ordenados
            container.innerHTML = '';
            cards.forEach(card => container.appendChild(card));
            
            // Destacar o botão ativo
            document.querySelectorAll('.btn-group .btn').forEach(btn => {
                btn.classList.remove('active', 'btn-light');
                btn.classList.add('btn-outline-light');
            });
            
            document.getElementById(`sort-${sortBy}-${order}`).classList.remove('btn-outline-light');
            document.getElementById(`sort-${sortBy}-${order}`).classList.add('active', 'btn-light');
        }
        
        // Função auxiliar para extrair o valor percentual do texto
        function parsePercentageValue(text) {
            if (text === 'Carregando...' || text === 'Sem dados') {
                return NaN;
            }
            
            // Extrair o número do texto (por exemplo, "+10.50%" -> 10.50)
            const match = text.match(/([+-]?\d+\.?\d*)%/);
            return match ? parseFloat(match[1]) : NaN;
        }
        
        // Inicializar os botões de classificação
        document.addEventListener('DOMContentLoaded', function() {
            // Adicionar event listeners para os botões de classificação
            document.getElementById('sort-alpha-asc').addEventListener('click', function() {
                sortSparklineCards('alpha', 'asc');
            });
            
            document.getElementById('sort-alpha-desc').addEventListener('click', function() {
                sortSparklineCards('alpha', 'desc');
            });
            
            document.getElementById('sort-percent-desc').addEventListener('click', function() {
                sortSparklineCards('percent', 'desc');
            });
            
            document.getElementById('sort-percent-asc').addEventListener('click', function() {
                sortSparklineCards('percent', 'asc');
            });
            
            // Adicionar event listener para o filtro de estrelas
            document.getElementById('starFilterToggle').addEventListener('change', function() {
                filterStarredItems(this.checked);
            });
        });
        
        // Função para filtrar itens com estrela
        function filterStarredItems(showOnlyStarred) {
            const cards = document.querySelectorAll('.col-md-3');
            
            cards.forEach(card => {
                const hasStarIndicator = card.querySelector('.sparkline-card .star-indicator') !== null;
                
                if (showOnlyStarred) {
                    // Se o filtro estiver ativado, mostrar apenas cartões com estrela
                    card.style.display = hasStarIndicator ? '' : 'none';
                } else {
                    // Se o filtro estiver desativado, mostrar todos os cartões
                    card.style.display = '';
                }
            });
        }
    </script>
</body>
</html>